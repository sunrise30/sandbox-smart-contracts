async function expectRevert(promise, expectedMessage) {
  if (typeof promise === 'undefined') {
    promise = expectedMessage;
    expectedMessage = null;
  }
  let receipt;
  try {
    receipt = await promise;
  } catch (error) {
    const isExpectedMessagePresent = !expectedMessage || error.message.search(expectedMessage) >= 0;
    if (!isExpectedMessagePresent) {
      throw new Error(`Revert message : "${expectedMessage}" not present, instead got : "${error.message}"`);
    }
    return true;
  }

  if (receipt.status === '0x0') {
    if (expectedMessage) {
      throw new Error(`Revert message not parsed : "${expectedMessage}"`);
    }
    return true;
  }
// throw new Error(`Revert expected`);
}

function recurseTests(test) {
  if (test.subTests) {
    // eslint-disable-next-line mocha/no-setup-in-describe
    describe(test.title, function () {
      // eslint-disable-next-line mocha/no-setup-in-describe
      for (const subTest of test.subTests) {
        // eslint-disable-next-line mocha/no-setup-in-describe
        recurse(subTest);
      }
    });
  } else {
    it(test.title, test.test);
  }
}

async function findEvents(contract, event, blockHash) {
  const filter = contract.filters[event]();
  const events = await contract.queryFilter(filter, blockHash)
  return events;
}

module.exports = {
  zeroAddress: '0x0000000000000000000000000000000000000000',
  emptyBytes: '0x',
  expectRevert,
  waitFor: (p) => p.then((tx) => tx.wait()),
  recurseTests,
  findEvents,
};
