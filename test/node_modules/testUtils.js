async function expectRevert(promise, expectedMessage) {
  if (typeof promise === 'undefined') {
    promise = expectedMessage;
    expectedMessage = null;
  }
  let receipt;
  try {
    receipt = await promise;
  } catch (error) {
    const isExpectedMessagePresent = !expectedMessage || error.message.search(expectedMessage) >= 0;
    if (!isExpectedMessagePresent) {
      throw new Error(`Revert message : "${expectedMessage}" not present, instead got : "${error.message}"`);
    }
    return true;
  }

  if (receipt.status === '0x0') {
    if (expectedMessage) {
      throw new Error(`Revert message not parsed : "${expectedMessage}"`);
    }
    return true;
  }
// throw new Error(`Revert expected`);
}

async function tx(contract, methodName, options, ...args) {
  if (!args) {
      args = [];
  }
  options = options || {};
  const overrides = {
      value: options.value ? BigNumber.from(options.value) : undefined,
      gasLimit: options.gas ? BigNumber.from(options.gas) : undefined,
      nonce: options.nonce ? BigNumber.from(options.nonce) : undefined,
  };
  args.push(overrides);
  const tx = await contract.connect(ethersProvider.getSigner(options.from)).functions[methodName](...args);
  return tx.wait();
}

let timeDelta = 0;

module.exports = {
  zeroAddress: '0x0000000000000000000000000000000000000000',
  emptyBytes: '0x',
  expectRevert,
  tx,
  getChainCurrentTime: () => Math.floor(Date.now() / 1000) + timeDelta,
};
