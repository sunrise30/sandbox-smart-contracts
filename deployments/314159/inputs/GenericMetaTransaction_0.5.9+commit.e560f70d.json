{"language":"Solidity","settings":{"evmVersion":"petersburg","libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":2000},"remappings":[]},"sources":{"contracts_common/src/BaseWithStorage/ProxyImplementation.sol":{"content":"pragma solidity ^0.5.2;\n\ncontract ProxyImplementation {\n    mapping(string => bool) _initialised;\n\n    modifier phase(string memory phaseName) {\n        if (!_initialised[phaseName]) {\n            _initialised[phaseName] = true;\n            _;\n        }\n    }\n}\n","keccak256":"0x9bfcb76a8aa264d0b33fb8b24c9401198a8e42ec8230ad6cc60ee628e3734fa4"},"contracts_common/src/Interfaces/ERC1271.sol":{"content":"pragma solidity ^0.5.2;\n\ncontract ERC1271 {\n\n    /**\n    * @dev Should return whether the signature provided is valid for the provided data\n    * @param data Arbitrary length data signed on the behalf of address(this)\n    * @param signature Signature byte array associated with _data\n    *\n    * MUST return the bytes4 magic value 0x20c13b0b when function passes.\n    * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n    * MUST allow external calls\n    */\n    function isValidSignature(bytes memory data, bytes memory signature)\n        public\n        view\n        returns (bytes4 magicValue);\n}\n","keccak256":"0xc96d98567763b067bb0264c9fed2a0df1e638b82e416c86e223e7e1cf2354514"},"contracts_common/src/Interfaces/ERC1271Constants.sol":{"content":"pragma solidity ^0.5.2;\n\ncontract ERC1271Constants {\n    bytes4 internal constant ERC1271_MAGICVALUE = 0x20c13b0b;\n}\n","keccak256":"0xe0fa0515924272c2536cc0e09428c456e0303d968cccbcb3395ea5237743c068"},"contracts_common/src/Interfaces/ERC20.sol":{"content":"pragma solidity ^0.5.2;\n\nimport \"./ERC20Basic.sol\";\n\n/**\n * @title ERC20 interface\n * @dev see https://eips.ethereum.org/EIPS/eip-20\n */\n/* interface */\ncontract ERC20 is ERC20Basic {\n    function transferFrom(address from, address to, uint256 value)\n        public\n        returns (bool);\n    function approve(address spender, uint256 value) public returns (bool);\n    function allowance(address owner, address spender)\n        public\n        view\n        returns (uint256);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n","keccak256":"0xa8cb63790e43bb77235530d0add180a84e9eb20c95173059e7d783c599c199b0"},"contracts_common/src/Interfaces/ERC20Basic.sol":{"content":"pragma solidity ^0.5.2;\n\n/**\n * @title ERC20Basic DRAFT\n * @dev Simpler version of ERC20 interface\n * See https://github.com/ethereum/EIPs/issues/179\n */\n/* interface */\ncontract ERC20Basic {\n    function totalSupply() public view returns (uint256);\n    function balanceOf(address who) public view returns (uint256);\n    function transfer(address to, uint256 value) public returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n}\n","keccak256":"0x7d333b4cd97e3fa0a67f3f20d79e6a46d5c81a8f7d506aa24c624ec6e4e913b9"},"contracts_common/src/Libraries/AddressUtils.sol":{"content":"pragma solidity ^0.5.2;\n\nlibrary AddressUtils {\n\n    function toPayable(address _address) internal pure returns (address payable _payable) {\n        return address(uint160(_address));\n    }\n\n    function isContract(address addr) internal view returns (bool) {\n        // for accounts without code, i.e. `keccak256('')`:\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        bytes32 codehash;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            codehash := extcodehash(addr)\n        }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n}\n","keccak256":"0x2ad037f43ea9a899526bd911737727d027ce8a2bc1cf615bdf5a1706d400afd6"},"contracts_common/src/Libraries/BytesUtil.sol":{"content":"pragma solidity ^0.5.2;\n\nlibrary BytesUtil {\n    function memcpy(uint256 dest, uint256 src, uint256 len) internal pure {\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        uint256 mask = 256**(32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    function pointerToBytes(uint256 src, uint256 len)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory ret = new bytes(len);\n        uint256 retptr;\n        assembly {\n            retptr := add(ret, 32)\n        }\n\n        memcpy(retptr, src, len);\n        return ret;\n    }\n\n    function addressToBytes(address a) internal pure returns (bytes memory b) {\n        assembly {\n            let m := mload(0x40)\n            mstore(\n                add(m, 20),\n                xor(0x140000000000000000000000000000000000000000, a)\n            )\n            mstore(0x40, add(m, 52))\n            b := m\n        }\n    }\n\n    function uint256ToBytes(uint256 a) internal pure returns (bytes memory b) {\n        assembly {\n            let m := mload(0x40)\n            mstore(add(m, 32), a)\n            mstore(0x40, add(m, 64))\n            b := m\n        }\n    }\n\n    function doFirstParamEqualsAddress(bytes memory data, address _address)\n        internal\n        pure\n        returns (bool)\n    {\n        if (data.length < (36 + 32)) {\n            return false;\n        }\n        uint256 value;\n        assembly {\n            value := mload(add(data, 36))\n        }\n        return value == uint256(_address);\n    }\n\n    function doParamEqualsUInt256(bytes memory data, uint256 i, uint256 value)\n        internal\n        pure\n        returns (bool)\n    {\n        if (data.length < (36 + (i + 1) * 32)) {\n            return false;\n        }\n        uint256 offset = 36 + i * 32;\n        uint256 valuePresent;\n        assembly {\n            valuePresent := mload(add(data, offset))\n        }\n        return valuePresent == value;\n    }\n\n    function overrideFirst32BytesWithAddress(\n        bytes memory data,\n        address _address\n    ) internal pure returns (bytes memory) {\n        uint256 dest;\n        assembly {\n            dest := add(data, 48)\n        } // 48 = 32 (offset) + 4 (func sig) + 12 (address is only 20 bytes)\n\n        bytes memory addressBytes = addressToBytes(_address);\n        uint256 src;\n        assembly {\n            src := add(addressBytes, 32)\n        }\n\n        memcpy(dest, src, 20);\n        return data;\n    }\n\n    function overrideFirstTwo32BytesWithAddressAndInt(\n        bytes memory data,\n        address _address,\n        uint256 _value\n    ) internal pure returns (bytes memory) {\n        uint256 dest;\n        uint256 src;\n\n        assembly {\n            dest := add(data, 48)\n        } // 48 = 32 (offset) + 4 (func sig) + 12 (address is only 20 bytes)\n        bytes memory bbytes = addressToBytes(_address);\n        assembly {\n            src := add(bbytes, 32)\n        }\n        memcpy(dest, src, 20);\n\n        assembly {\n            dest := add(data, 68)\n        } // 48 = 32 (offset) + 4 (func sig) + 32 (next slot)\n        bbytes = uint256ToBytes(_value);\n        assembly {\n            src := add(bbytes, 32)\n        }\n        memcpy(dest, src, 32);\n\n        return data;\n    }\n}\n","keccak256":"0xb5c236938e1f71524127371a015836e83103c5ac1b4ed7b7f22892a8c0429e10"},"contracts_common/src/Libraries/SafeMath.sol":{"content":"pragma solidity ^0.5.2;\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n    /**\n    * @dev Multiplies two numbers, throws on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        // uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return a / b;\n    }\n\n    /**\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    /**\n    * @dev Adds two numbers, throws on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n","keccak256":"0x55d3e77e8ca8c1f47ed120ef7a1b288e999c2bdb7a508dfa533494f9b9849002"},"contracts_common/src/Libraries/SigUtil.sol":{"content":"pragma solidity ^0.5.2;\n\nlibrary SigUtil {\n    function recover(bytes32 hash, bytes memory sig)\n        internal\n        pure\n        returns (address recovered)\n    {\n        require(sig.length == 65);\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n        if (v < 27) {\n            v += 27;\n        }\n        require(v == 27 || v == 28);\n\n        recovered = ecrecover(hash, v, r, s);\n        require(recovered != address(0));\n    }\n\n    function recoverWithZeroOnFailure(bytes32 hash, bytes memory sig)\n        internal\n        pure\n        returns (address)\n    {\n        if (sig.length != 65) {\n            return (address(0));\n        }\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n        if (v < 27) {\n            v += 27;\n        }\n\n        if (v != 27 && v != 28) {\n            return (address(0));\n        } else {\n            return ecrecover(hash, v, r, s);\n        }\n    }\n\n    // Builds a prefixed hash to mimic the behavior of eth_sign.\n    function prefixed(bytes32 hash) internal pure returns (bytes memory) {\n        return abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash);\n    }\n}\n","keccak256":"0xda7729e5b24c3780242ed1923b2a709ab284c18ee533669d6d0fa394ffb0491b"},"src/GenericMetaTransaction.sol":{"content":"pragma solidity 0.5.9;\n\nimport \"../contracts_common/src/Libraries/BytesUtil.sol\";\nimport \"../contracts_common/src/Libraries/AddressUtils.sol\";\nimport \"../contracts_common/src/Libraries/SigUtil.sol\";\nimport \"../contracts_common/src/Libraries/SafeMath.sol\";\nimport \"../contracts_common/src/Interfaces/ERC1271.sol\";\nimport \"../contracts_common/src/Interfaces/ERC20.sol\";\nimport \"../contracts_common/src/Interfaces/ERC1271Constants.sol\";\nimport \"./TheSandbox712.sol\";\n\ncontract GenericMetaTransaction is TheSandbox712, ERC1271Constants {\n    using SafeMath for uint256;\n    using AddressUtils for address;\n\n    bytes32 constant ERC20METATRANSACTION_TYPEHASH = keccak256(\n        \"ERC20MetaTransaction(address from,address to,address gasToken,bytes data,uint256 nonce,uint256 gasPrice,uint256 txGas,uint256 gasLimit,uint256 tokenGasPrice,address relayer)\"\n    );\n    mapping(address => uint256) nonces;\n\n    uint256 constant BASE_GAS = 112000; // TODO calculate accurately\n    uint256 constant WORST_CASE_EPSILON = 10000; // TODO calculate accurately\n    uint256 constant INIT_GAS = 23000; // TODO calculate accurately\n\n    event MetaTx(bool success, bytes returnData); // TODO specify event as part of ERC-1776\n\n    constructor() public {\n        init712();\n    }\n\n    function ensureParametersValidity(\n        address _from,\n        address _gasToken,\n        uint256[4] memory params, // _nonce, _gasPrice, _txGas, _tokenGasPrice\n        address _relayer\n    ) internal view {\n        require(\n            _relayer == address(0) || _relayer == msg.sender,\n            \"wrong relayer\"\n        );\n        require(nonces[_from] + 1 == params[0], \"nonce out of order\");\n        require(\n            ERC20(_gasToken).balanceOf(_from) >=\n                (params[2].add(BASE_GAS)).mul(params[3]),\n            \"_from not enough balance\"\n        );\n        require(tx.gasprice == params[1], \"gasPrice != signer gasPrice\"); // need to provide same gasPrice as requested by signer // TODO consider allowing higher value\n    }\n\n    function encodeData(\n        bytes32 typeHash,\n        address _from,\n        address _to,\n        address _gasToken,\n        bytes memory _data,\n        uint256[4] memory params,\n        address _relayer\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    typeHash,\n                    _from,\n                    _to,\n                    _gasToken,\n                    keccak256(_data),\n                    params[0],\n                    params[1],\n                    params[2],\n                    BASE_GAS + params[2], // expect signing gasLimit = BASE_GAS + txGas\n                    params[3],\n                    _relayer\n                )\n            );\n    }\n\n    function ensureCorrectSigner(\n        address _from,\n        address _to,\n        address _gasToken,\n        bytes memory _data,\n        uint256[4] memory params,\n        address _relayer,\n        bytes memory _sig,\n        bytes32 typeHash,\n        bool signedOnBehalf\n    ) internal view {\n        bytes memory data = abi.encodePacked(\n            \"\\x19\\x01\",\n            domainSeparator(),\n            encodeData(typeHash, _from, _to, _gasToken, _data, params, _relayer)\n        );\n        if (signedOnBehalf) {\n            require(\n                ERC1271(_from).isValidSignature(data, _sig) ==\n                    ERC1271_MAGICVALUE,\n                \"invalid signature\"\n            );\n        } else {\n            address signer = SigUtil.recover(keccak256(data), _sig);\n            require(signer == _from, \"signer != _from\");\n        }\n    }\n\n    function sendERC20Tokens(\n        address _from,\n        address _to,\n        ERC20 _tokenContract,\n        uint256 _amount,\n        bytes calldata _data\n    ) external {\n        require(msg.sender == address(this), \"can only be called by own\");\n        _tokenContract.transferFrom(_from, _to, _amount);\n        bool success = true;\n        bytes memory returnData;\n        if (_to.isContract() || _data.length > 0) {\n            (success, returnData) = _to.call(\n                abi.encodeWithSignature(\n                    \"erc20_tokensReceived(address,address,uint256,bytes)\",\n                    _from,\n                    _tokenContract,\n                    _amount,\n                    _data\n                )\n            );\n        }\n        require(success);\n    }\n\n    // function sendERC777Tokens(address _from, address _to, ERC777 _tokenContract, uint256 _amount, bytes calldata _data) external {\n    //     require(msg.sender == address(this), \"can only be called by own\");\n    //     _tokenContract.operatorSend(_from, _to, _amount, _data);\n    // }\n\n    // TODO safe /unsafe version\n    // function sendERC1155Tokens(address _from, address _to, ERC1155 _tokenContract, uint256 _tokenType, uint256 _amount, bytes calldata _data) external {\n    //     require(msg.sender == address(this), \"can only be called by own\");\n    //     _tokenContract.transfer...(_from, _to, _amount, _data);\n    // }\n\n    // TODO safe /unsafe version\n    // function sendERC721Tokens(address _from, address _to, ERC721 _tokenContract, uint256 _tokenType, bytes calldata _data) external {\n    //     require(msg.sender == address(this), \"can only be called by own\");\n    //     _tokenContract.transferFrom(_from, _to, _amount, _data);\n    // }\n\n    function executeERC20MetaTx(\n        address _from,\n        address _to,\n        address _gasToken,\n        bytes calldata _data,\n        uint256[4] calldata params, // _nonce, _gasPrice, _txGas, _tokenGasPrice\n        address _relayer,\n        bytes calldata _sig,\n        address _tokenReceiver,\n        bool signedOnBehalf\n    ) external returns (bool, bytes memory) {\n        require(msg.sender != address(this), \"can only be called externaly\");\n        uint256 initialGas = gasleft();\n        ensureParametersValidity(_from, _gasToken, params, _relayer);\n        ensureCorrectSigner(\n            _from,\n            _to,\n            _gasToken,\n            _data,\n            params,\n            _relayer,\n            _sig,\n            ERC20METATRANSACTION_TYPEHASH,\n            signedOnBehalf\n        );\n        return\n            performERC20MetaTx(\n                _from,\n                _to,\n                _gasToken,\n                _data,\n                params,\n                initialGas,\n                _tokenReceiver\n            );\n    }\n\n    function performERC20MetaTx(\n        address _from,\n        address _to,\n        address _gasToken,\n        bytes memory _data,\n        uint256[4] memory params,\n        uint256 initialGas,\n        address _tokenReceiver\n    ) internal returns (bool, bytes memory) {\n        nonces[_from] = params[0];\n\n        bool success;\n        bytes memory returnData;\n\n        if (_to == address(this)) {\n            require(\n                BytesUtil.doFirstParamEqualsAddress(_data, _from),\n                \"first param != _from\"\n            );\n            uint256 gasAvailable = gasleft() - WORST_CASE_EPSILON;\n            require(\n                gasAvailable - gasAvailable / 64 > params[2],\n                \"not enough gas\"\n            );\n            (success, returnData) = _to.call.gas(params[2])(_data);\n        } else {\n            // can't accept any call since this contract willmost likely be approved by ERC20 or ERC777 contract and if those have function that\n            // have such signature for example differentTransfer(uint256 amount, address from, ...) they would be vulnerable\n            //so instead we define a meta_transaction hook\n            uint256 gasAvailable = gasleft() - WORST_CASE_EPSILON;\n            require(\n                gasAvailable - gasAvailable / 64 > params[2],\n                \"not enough gas\"\n            );\n            (success, returnData) = _to.call.gas(params[2])(\n                abi.encodeWithSignature(\n                    \"meta_transaction_received(address,bytes)\",\n                    _from,\n                    _data\n                )\n            );\n        }\n\n        emit MetaTx(success, returnData);\n\n        if (params[3] > 0) {\n            uint256 gasConsumed = (initialGas + INIT_GAS) - gasleft();\n            if (gasConsumed > BASE_GAS + params[2]) {\n                gasConsumed = BASE_GAS + params[2];\n                // idealy we would like to charge only max(BASE_GAS, gas consumed outside the inner call) + gas consumed as part of the inner call\n            }\n            ERC20(_gasToken).transferFrom(\n                _from,\n                _tokenReceiver,\n                gasConsumed * params[3]\n            );\n        }\n\n        return (success, returnData);\n    }\n\n    function meta_nonce(address _from) external view returns (uint256 nonce) {\n        return nonces[_from];\n    }\n}\n","keccak256":"0x4733299f33984caeb472d4ce7d0e888c0bf5d21bbe7f7df13813b1352034f5ab"},"src/TheSandbox712.sol":{"content":"pragma solidity 0.5.9;\n\nimport {\n    ProxyImplementation\n} from \"../contracts_common/src/BaseWithStorage/ProxyImplementation.sol\";\n\ncontract TheSandbox712 is ProxyImplementation {\n    bytes32 constant EIP712DOMAIN_TYPEHASH = keccak256(\n        \"EIP712Domain(string name,string version,address verifyingContract)\"\n    );\n    bytes32 DOMAIN_SEPARATOR;\n\n    function init712() public phase(\"712\") {\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                EIP712DOMAIN_TYPEHASH,\n                keccak256(\"The Sandbox 3D\"),\n                keccak256(\"1\"),\n                address(this)\n            )\n        );\n    }\n\n    function domainSeparator() internal view returns (bytes32) {\n        return DOMAIN_SEPARATOR;\n    }\n}\n","keccak256":"0x76f0233c0b532620a8d3a129d30b6551869be42514cbe2b03004400ea230de54"}}}