{"language":"Solidity","settings":{"evmVersion":"petersburg","libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":2000},"remappings":[]},"sources":{"contracts_common/src/BaseWithStorage/Admin.sol":{"content":"pragma solidity ^0.5.2;\n\ncontract Admin {\n\n    address internal _admin;\n\n    event AdminChanged(address oldAdmin, address newAdmin);\n\n    /// @notice gives the current administrator of this contract.\n    /// @return the current administrator of this contract.\n    function getAdmin() external view returns (address) {\n        return _admin;\n    }\n\n    /// @notice change the administrator to be `newAdmin`.\n    /// @param newAdmin address of the new administrator.\n    function changeAdmin(address newAdmin) external {\n        require(msg.sender == _admin, \"only admin can change admin\");\n        emit AdminChanged(_admin, newAdmin);\n        _admin = newAdmin;\n    }\n\n    modifier onlyAdmin() {\n        require (msg.sender == _admin, \"only admin allowed\");\n        _;\n    }\n\n}\n","keccak256":"0xf3763fa108235379b48cf8fe9a708692fcb077250d9974351fd636ff0baf84bf"},"contracts_common/src/BaseWithStorage/SuperOperators.sol":{"content":"pragma solidity ^0.5.2;\n\nimport \"./Admin.sol\";\n\ncontract SuperOperators is Admin {\n\n    mapping(address => bool) internal _superOperators;\n\n    event SuperOperator(address superOperator, bool enabled);\n\n    /// @notice Enable or disable the ability of `superOperator` to transfer tokens of all (superOperator rights).\n    /// @param superOperator address that will be given/removed superOperator right.\n    /// @param enabled set whether the superOperator is enabled or disabled.\n    function setSuperOperator(address superOperator, bool enabled) external {\n        require(\n            msg.sender == _admin,\n            \"only admin is allowed to add super operators\"\n        );\n        _superOperators[superOperator] = enabled;\n        emit SuperOperator(superOperator, enabled);\n    }\n\n    /// @notice check whether address `who` is given superOperator rights.\n    /// @param who The address to query.\n    /// @return whether the address has superOperator rights.\n    function isSuperOperator(address who) public view returns (bool) {\n        return _superOperators[who];\n    }\n}\n","keccak256":"0x22354cf60ccf77a6de61c13bdaf4e3094d115b960ae563b0527622c846a12abb"},"contracts_common/src/Interfaces/ERC1155.sol":{"content":"pragma solidity ^0.5.2;\n\n/**\n    @title ERC-1155 Multi Token Standard\n    @dev See https://eips.ethereum.org/EIPS/eip-1155\n    Note: The ERC-165 identifier for this interface is 0xd9b67a26.\n */\ninterface ERC1155 {\n\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 value\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    event URI(string value, uint256 indexed id);\n\n    /**\n        @notice Transfers `value` amount of an `id` from  `from` to `to`  (with safety call).\n        @dev Caller must be approved to manage the tokens being transferred out of the `from` account (see \"Approval\" section of the standard).\n        MUST revert if `to` is the zero address.\n        MUST revert if balance of holder for token `id` is lower than the `value` sent.\n        MUST revert on any other error.\n        MUST emit the `TransferSingle` event to reflect the balance change (see \"Safe Transfer Rules\" section of the standard).\n        After the above conditions are met, this function MUST check if `to` is a smart contract (e.g. code size > 0). If so, it MUST call `onERC1155Received` on `to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).\n        @param from    Source address\n        @param to      Target address\n        @param id      ID of the token type\n        @param value   Transfer amount\n        @param data    Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `to`\n    */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external;\n\n    /**\n        @notice Transfers `values` amount(s) of `ids` from the `from` address to the `to` address specified (with safety call).\n        @dev Caller must be approved to manage the tokens being transferred out of the `from` account (see \"Approval\" section of the standard).\n        MUST revert if `to` is the zero address.\n        MUST revert if length of `ids` is not the same as length of `values`.\n        MUST revert if any of the balance(s) of the holder(s) for token(s) in `ids` is lower than the respective amount(s) in `values` sent to the recipient.\n        MUST revert on any other error.\n        MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see \"Safe Transfer Rules\" section of the standard).\n        Balance changes and events MUST follow the ordering of the arrays (_ids[0]/_values[0] before _ids[1]/_values[1], etc).\n        After the above conditions for the transfer(s) in the batch are met, this function MUST check if `to` is a smart contract (e.g. code size > 0). If so, it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).\n        @param from    Source address\n        @param to      Target address\n        @param ids     IDs of each token type (order and length must match _values array)\n        @param values  Transfer amounts per token type (order and length must match _ids array)\n        @param data    Additional data with no specified format, MUST be sent unaltered in call to the `ERC1155TokenReceiver` hook(s) on `to`\n    */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external;\n\n    /**\n        @notice Get the balance of an account's tokens.\n        @param owner  The address of the token holder\n        @param id     ID of the token\n        @return        The _owner's balance of the token type requested\n     */\n    function balanceOf(address owner, uint256 id)\n        external\n        view\n        returns (uint256);\n\n    /**\n        @notice Get the balance of multiple account/token pairs\n        @param owners The addresses of the token holders\n        @param ids    ID of the tokens\n        @return        The _owner's balance of the token types requested (i.e. balance for each (owner, id) pair)\n     */\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n        @notice Enable or disable approval for a third party (\"operator\") to manage all of the caller's tokens.\n        @dev MUST emit the ApprovalForAll event on success.\n        @param operator  Address to add to the set of authorized operators\n        @param approved  True if the operator is approved, false to revoke approval\n    */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n        @notice Queries the approval status of an operator for a given owner.\n        @param owner     The owner of the tokens\n        @param operator  Address of authorized operator\n        @return           True if the operator is approved, false if not\n    */\n    function isApprovedForAll(address owner, address operator)\n        external\n        view\n        returns (bool);\n}\n","keccak256":"0xadc315968f24479f9e6e5cbdfb32a3a8d6b83061afb0680ad3a73959e40e447f"},"contracts_common/src/Interfaces/ERC1155TokenReceiver.sol":{"content":"pragma solidity ^0.5.2;\n\n/**\n    Note: The ERC-165 identifier for this interface is 0x4e2312e0.\n*/\ninterface ERC1155TokenReceiver {\n    /**\n        @notice Handle the receipt of a single ERC1155 token type.\n        @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated.\n        This function MUST return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` (i.e. 0xf23a6e61) if it accepts the transfer.\n        This function MUST revert if it rejects the transfer.\n        Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\n        @param operator  The address which initiated the transfer (i.e. msg.sender)\n        @param from      The address which previously owned the token\n        @param id        The ID of the token being transferred\n        @param value     The amount of tokens being transferred\n        @param data      Additional data with no specified format\n        @return           `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n        @notice Handle the receipt of multiple ERC1155 token types.\n        @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated.\n        This function MUST return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` (i.e. 0xbc197c81) if it accepts the transfer(s).\n        This function MUST revert if it rejects the transfer(s).\n        Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\n        @param operator  The address which initiated the batch transfer (i.e. msg.sender)\n        @param from      The address which previously owned the token\n        @param ids       An array containing ids of each token being transferred (order and length must match _values array)\n        @param values    An array containing amounts of each token being transferred (order and length must match _ids array)\n        @param data      Additional data with no specified format\n        @return           `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n","keccak256":"0x915c81f5684876945b81020f620aa6261a7bf3a1bf0c07f1eada0e88200872de"},"contracts_common/src/Interfaces/ERC20.sol":{"content":"pragma solidity ^0.5.2;\n\nimport \"./ERC20Basic.sol\";\n\n/**\n * @title ERC20 interface\n * @dev see https://eips.ethereum.org/EIPS/eip-20\n */\n/* interface */\ncontract ERC20 is ERC20Basic {\n    function transferFrom(address from, address to, uint256 value)\n        public\n        returns (bool);\n    function approve(address spender, uint256 value) public returns (bool);\n    function allowance(address owner, address spender)\n        public\n        view\n        returns (uint256);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n","keccak256":"0xa8cb63790e43bb77235530d0add180a84e9eb20c95173059e7d783c599c199b0"},"contracts_common/src/Interfaces/ERC20Basic.sol":{"content":"pragma solidity ^0.5.2;\n\n/**\n * @title ERC20Basic DRAFT\n * @dev Simpler version of ERC20 interface\n * See https://github.com/ethereum/EIPs/issues/179\n */\n/* interface */\ncontract ERC20Basic {\n    function totalSupply() public view returns (uint256);\n    function balanceOf(address who) public view returns (uint256);\n    function transfer(address to, uint256 value) public returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n}\n","keccak256":"0x7d333b4cd97e3fa0a67f3f20d79e6a46d5c81a8f7d506aa24c624ec6e4e913b9"},"contracts_common/src/Interfaces/ERC20Events.sol":{"content":"pragma solidity ^0.5.2;\n\n/* interface */\ncontract ERC20Events {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n","keccak256":"0xee09c10a3f9adc913227efdcd94ce44e05b59b04717f8f868153d356bd03f5d2"},"contracts_common/src/Libraries/AddressUtils.sol":{"content":"pragma solidity ^0.5.2;\n\nlibrary AddressUtils {\n\n    function toPayable(address _address) internal pure returns (address payable _payable) {\n        return address(uint160(_address));\n    }\n\n    function isContract(address addr) internal view returns (bool) {\n        // for accounts without code, i.e. `keccak256('')`:\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        bytes32 codehash;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            codehash := extcodehash(addr)\n        }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n}\n","keccak256":"0x2ad037f43ea9a899526bd911737727d027ce8a2bc1cf615bdf5a1706d400afd6"},"contracts_common/src/Libraries/BytesUtil.sol":{"content":"pragma solidity ^0.5.2;\n\nlibrary BytesUtil {\n    function memcpy(uint256 dest, uint256 src, uint256 len) internal pure {\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        uint256 mask = 256**(32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    function pointerToBytes(uint256 src, uint256 len)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory ret = new bytes(len);\n        uint256 retptr;\n        assembly {\n            retptr := add(ret, 32)\n        }\n\n        memcpy(retptr, src, len);\n        return ret;\n    }\n\n    function addressToBytes(address a) internal pure returns (bytes memory b) {\n        assembly {\n            let m := mload(0x40)\n            mstore(\n                add(m, 20),\n                xor(0x140000000000000000000000000000000000000000, a)\n            )\n            mstore(0x40, add(m, 52))\n            b := m\n        }\n    }\n\n    function uint256ToBytes(uint256 a) internal pure returns (bytes memory b) {\n        assembly {\n            let m := mload(0x40)\n            mstore(add(m, 32), a)\n            mstore(0x40, add(m, 64))\n            b := m\n        }\n    }\n\n    function doFirstParamEqualsAddress(bytes memory data, address _address)\n        internal\n        pure\n        returns (bool)\n    {\n        if (data.length < (36 + 32)) {\n            return false;\n        }\n        uint256 value;\n        assembly {\n            value := mload(add(data, 36))\n        }\n        return value == uint256(_address);\n    }\n\n    function doParamEqualsUInt256(bytes memory data, uint256 i, uint256 value)\n        internal\n        pure\n        returns (bool)\n    {\n        if (data.length < (36 + (i + 1) * 32)) {\n            return false;\n        }\n        uint256 offset = 36 + i * 32;\n        uint256 valuePresent;\n        assembly {\n            valuePresent := mload(add(data, offset))\n        }\n        return valuePresent == value;\n    }\n\n    function overrideFirst32BytesWithAddress(\n        bytes memory data,\n        address _address\n    ) internal pure returns (bytes memory) {\n        uint256 dest;\n        assembly {\n            dest := add(data, 48)\n        } // 48 = 32 (offset) + 4 (func sig) + 12 (address is only 20 bytes)\n\n        bytes memory addressBytes = addressToBytes(_address);\n        uint256 src;\n        assembly {\n            src := add(addressBytes, 32)\n        }\n\n        memcpy(dest, src, 20);\n        return data;\n    }\n\n    function overrideFirstTwo32BytesWithAddressAndInt(\n        bytes memory data,\n        address _address,\n        uint256 _value\n    ) internal pure returns (bytes memory) {\n        uint256 dest;\n        uint256 src;\n\n        assembly {\n            dest := add(data, 48)\n        } // 48 = 32 (offset) + 4 (func sig) + 12 (address is only 20 bytes)\n        bytes memory bbytes = addressToBytes(_address);\n        assembly {\n            src := add(bbytes, 32)\n        }\n        memcpy(dest, src, 20);\n\n        assembly {\n            dest := add(data, 68)\n        } // 48 = 32 (offset) + 4 (func sig) + 32 (next slot)\n        bbytes = uint256ToBytes(_value);\n        assembly {\n            src := add(bbytes, 32)\n        }\n        memcpy(dest, src, 32);\n\n        return data;\n    }\n}\n","keccak256":"0xb5c236938e1f71524127371a015836e83103c5ac1b4ed7b7f22892a8c0429e10"},"contracts_common/src/Libraries/ObjectLib64.sol":{"content":"pragma solidity ^0.5.2;\n\nimport \"./SafeMathWithRequire.sol\";\n\nlibrary ObjectLib64 {\n    using SafeMathWithRequire for uint256;\n    enum Operations {ADD, SUB, REPLACE}\n    // Constants regarding bin or chunk sizes for balance packing\n    uint256 constant TYPES_BITS_SIZE = 64; // Max size of each object\n    uint256 constant TYPES_PER_UINT256 = 256 / TYPES_BITS_SIZE; // Number of types per uint256\n\n    //\n    // Objects and Tokens Functions\n    //\n\n    /**\n  * @dev Return the bin number and index within that bin where ID is\n  * @param _tokenId Object type\n  * @return (Bin number, ID's index within that bin)\n  */\n    function getTokenBinIndex(uint256 _tokenId)\n        internal\n        pure\n        returns (uint256 bin, uint256 index)\n    {\n        bin = (_tokenId * TYPES_BITS_SIZE) / 256;\n        index = _tokenId % TYPES_PER_UINT256;\n        return (bin, index);\n    }\n\n    /**\n  * @dev update the balance of a type provided in _binBalances\n  * @param _binBalances Uint256 containing the balances of objects\n  * @param _index Index of the object in the provided bin\n  * @param _amount Value to update the type balance\n  * @param _operation Which operation to conduct :\n  *     Operations.REPLACE : Replace type balance with _amount\n  *     Operations.ADD     : ADD _amount to type balance\n  *     Operations.SUB     : Substract _amount from type balance\n  */\n    function updateTokenBalance(\n        uint256 _binBalances,\n        uint256 _index,\n        uint256 _amount,\n        Operations _operation\n    ) internal pure returns (uint256 newBinBalance) {\n        uint256 objectBalance = 0;\n        if (_operation == Operations.ADD) {\n            objectBalance = getValueInBin(_binBalances, _index);\n            newBinBalance = writeValueInBin(\n                _binBalances,\n                _index,\n                objectBalance.add(_amount)\n            );\n        } else if (_operation == Operations.SUB) {\n            objectBalance = getValueInBin(_binBalances, _index);\n            newBinBalance = writeValueInBin(\n                _binBalances,\n                _index,\n                objectBalance.sub(_amount)\n            );\n        } else if (_operation == Operations.REPLACE) {\n            newBinBalance = writeValueInBin(_binBalances, _index, _amount);\n        } else {\n            revert(\"Invalid operation\"); // Bad operation\n        }\n\n        return newBinBalance;\n    }\n    /*\n  * @dev return value in _binValue at position _index\n  * @param _binValue uint256 containing the balances of TYPES_PER_UINT256 types\n  * @param _index index at which to retrieve value\n  * @return Value at given _index in _bin\n  */\n    function getValueInBin(uint256 _binValue, uint256 _index)\n        internal\n        pure\n        returns (uint256)\n    {\n        // Mask to retrieve data for a given binData\n        uint256 mask = (uint256(1) << TYPES_BITS_SIZE) - 1;\n\n        // Shift amount\n        uint256 rightShift = 256 - TYPES_BITS_SIZE * (_index + 1);\n        return (_binValue >> rightShift) & mask;\n    }\n\n    /**\n  * @dev return the updated _binValue after writing _amount at _index\n  * @param _binValue uint256 containing the balances of TYPES_PER_UINT256 types\n  * @param _index Index at which to retrieve value\n  * @param _amount Value to store at _index in _bin\n  * @return Value at given _index in _bin\n  */\n    function writeValueInBin(uint256 _binValue, uint256 _index, uint256 _amount)\n        internal\n        pure\n        returns (uint256)\n    {\n        require(\n            _amount < 2**TYPES_BITS_SIZE,\n            \"Amount to write in bin is too large\"\n        );\n\n        // Mask to retrieve data for a given binData\n        uint256 mask = (uint256(1) << TYPES_BITS_SIZE) - 1;\n\n        // Shift amount\n        uint256 leftShift = 256 - TYPES_BITS_SIZE * (_index + 1);\n        return (_binValue & ~(mask << leftShift)) | (_amount << leftShift);\n    }\n\n}\n","keccak256":"0xb83c349da8cb7578d7765a0c4d5b8ed7ccf08e1e96941df35af63a252ad07db8"},"contracts_common/src/Libraries/SafeMath.sol":{"content":"pragma solidity ^0.5.2;\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n    /**\n    * @dev Multiplies two numbers, throws on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        // uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return a / b;\n    }\n\n    /**\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    /**\n    * @dev Adds two numbers, throws on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n","keccak256":"0x55d3e77e8ca8c1f47ed120ef7a1b288e999c2bdb7a508dfa533494f9b9849002"},"contracts_common/src/Libraries/SafeMathWithRequire.sol":{"content":"pragma solidity ^0.5.2;\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert\n */\nlibrary SafeMathWithRequire {\n    /**\n    * @dev Multiplies two numbers, throws on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        c = a * b;\n        require(c / a == b, \"overflow\");\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        // uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return a / b;\n    }\n\n    /**\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"undeflow\");\n        return a - b;\n    }\n\n    /**\n    * @dev Adds two numbers, throws on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        c = a + b;\n        require(c >= a, \"overflow\");\n        return c;\n    }\n}\n","keccak256":"0x362e750dc8b68acf6b56e0e78c6e8801b5d08031cfc77576e3222e5f42d99313"},"src/Orbs/ERC20ORB.sol":{"content":"pragma solidity 0.5.9;\n\nimport {ERC20} from \"../../contracts_common/src/Interfaces/ERC20.sol\";\nimport {\n    ERC20Events\n} from \"../../contracts_common/src/Interfaces/ERC20Events.sol\";\nimport \"../../contracts_common/src/Libraries/SafeMath.sol\";\nimport \"../../contracts_common/src/BaseWithStorage/SuperOperators.sol\";\n\nimport \"./ORBCore.sol\";\n\ncontract ERC20ORB is\n    ERC20Events,\n    SuperOperators /*is ERC20*/\n{\n    using SafeMath for uint256;\n\n    struct Origin {\n        ORBCore core;\n        uint8 index;\n    }\n\n    Origin origin;\n    mapping(address => mapping(address => uint256)) internal mAllowed;\n\n    constructor(ORBCore _core, uint8 _index) public {\n        origin = Origin(_core, _index);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return origin.core.supplyOf(origin.index);\n    }\n\n    function balanceOf(address who) public view returns (uint256) {\n        return origin.core.balanceOf(who, origin.index);\n    }\n\n    function decimals() public view returns (uint8) {\n        return uint8(18);\n    }\n\n    function transfer(address _to, uint256 _amount)\n        public\n        returns (bool success)\n    {\n        _transfer(msg.sender, _to, _amount);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _amount)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != _from && !_superOperators[msg.sender]) {\n            uint256 allowance = mAllowed[_from][msg.sender];\n            if (allowance != (2**256) - 1) {\n                // save gas when allowance is maximal by not reducing it (see https://github.com/ethereum/EIPs/issues/717)\n                require(allowance >= _amount, \"Not enough funds allowed\");\n                mAllowed[_from][msg.sender] = allowance.sub(_amount);\n            }\n        }\n        _transfer(_from, _to, _amount);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _amount)\n        public\n        returns (bool success)\n    {\n        _approveFor(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    function approveFor(address from, address _spender, uint256 _amount)\n        public\n        returns (bool success)\n    {\n        require(\n            msg.sender == from || _superOperators[msg.sender],\n            \"msg.sender != from || superOperator\"\n        );\n        _approveFor(from, _spender, _amount);\n        return true;\n    }\n\n    function _approveFor(address _owner, address _spender, uint256 _amount)\n        internal\n    {\n        require(\n            _owner != address(0) && _spender != address(0),\n            \"Cannot approve with 0x0\"\n        );\n        mAllowed[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    function allowance(address _owner, address _spender)\n        public\n        view\n        returns (uint256 remaining)\n    {\n        return mAllowed[_owner][_spender];\n    }\n\n    function _transfer(address _from, address _to, uint256 _amount) internal {\n        origin.core.transferFrom(_from, _to, origin.index, _amount);\n    }\n\n    function emitTransferEvent(address _from, address _to, uint256 _amount)\n        external\n    {\n        require(msg.sender == address(origin.core), \"only core\");\n        emit Transfer(_from, _to, _amount);\n    }\n}\n","keccak256":"0x45948fc22ab622c8f55fa6c423bc31a403974a42393ebd50e7dd28c913384d4b"},"src/Orbs/ORBCore.sol":{"content":"pragma solidity 0.5.9;\n\nimport \"./ERC20ORB.sol\";\nimport \"../../contracts_common/src/Libraries/SafeMath.sol\";\nimport \"../../contracts_common/src/Libraries/AddressUtils.sol\";\nimport \"../../contracts_common/src/Libraries/ObjectLib64.sol\";\nimport \"../../contracts_common/src/Libraries/BytesUtil.sol\";\n\nimport \"../../contracts_common/src/Interfaces/ERC1155.sol\";\nimport \"../../contracts_common/src/Interfaces/ERC1155TokenReceiver.sol\";\n\nimport \"../../contracts_common/src/BaseWithStorage/SuperOperators.sol\";\n\ncontract ORBCore is SuperOperators, ERC1155 {\n    using AddressUtils for address;\n    using ObjectLib64 for ObjectLib64.Operations;\n    using ObjectLib64 for uint256;\n    using SafeMath for uint256;\n    mapping(address => uint256) packedTokenBalance;\n    mapping(address => mapping(address => bool)) operatorsForAll;\n\n    mapping(address => bool) metaTransactionContracts; // native meta-transaction support\n    \n    uint256[3] totalSupplies;\n    ERC20ORB[3] erc20s;\n    event ORB(ERC20ORB orb);\n    constructor(address _to, uint256 supply0, uint256 supply1, uint256 supply2)\n        public\n    {\n        deployORB(0, supply0, _to);\n        deployORB(1, supply1, _to);\n        deployORB(2, supply2, _to);\n    }\n\n    function deployORB(uint8 index, uint256 supply, address _to) internal {\n        ERC20ORB orb = new ERC20ORB(this, index);\n\n        packedTokenBalance[_to] = packedTokenBalance[_to].updateTokenBalance(\n            index,\n            supply,\n            ObjectLib64.Operations.REPLACE\n        );\n        totalSupplies[index] = supply;\n\n        orb.emitTransferEvent(address(0), _to, supply);\n\n        erc20s[index] = orb;\n        emit ORB(orb);\n    }\n\n    function supplyOf(uint256 _id) external view returns (uint256) {\n        if (_id > 2) {\n            return 0;\n        }\n        return totalSupplies[_id];\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _id,\n        uint256 _value\n    ) external {\n        require(msg.sender == address(erc20s[_id]), \"only sub erc20\");\n        _transferFrom(_from, _to, _id, _value);\n        require( // solium-disable-line error-reason\n            _checkERC1155AndCallSafeTransfer(\n                metaTransactionContracts[msg.sender] ? _from : msg.sender,\n                _from,\n                _to,\n                _id,\n                _value,\n                \"\",\n                true\n            ),\n            \"failCheck\"\n        );\n    }\n\n    function _transferFrom(\n        address _from,\n        address _to,\n        uint256 _id,\n        uint256 _value\n    ) internal {\n        require(_to != address(0), \"Invalid to address\");\n        ERC20ORB erc20 = erc20s[_id];\n        if (\n            _from != msg.sender &&\n            !metaTransactionContracts[msg.sender] &&\n            msg.sender != address(erc20)\n        ) {\n            require(\n                _superOperators[msg.sender] ||\n                    operatorsForAll[_from][msg.sender],\n                \"Operator not approved\"\n            );\n        }\n\n        packedTokenBalance[_from] = packedTokenBalance[_from]\n            .updateTokenBalance(_id, _value, ObjectLib64.Operations.SUB);\n        packedTokenBalance[_to] = packedTokenBalance[_to].updateTokenBalance(\n            _id,\n            _value,\n            ObjectLib64.Operations.ADD\n        );\n        emit TransferSingle(\n            metaTransactionContracts[msg.sender] ? _from : msg.sender,\n            _from,\n            _to,\n            _id,\n            _value\n        );\n        erc20.emitTransferEvent(_from, _to, _value);\n    }\n\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _id,\n        uint256 _value,\n        bytes calldata _data\n    ) external {\n        _transferFrom(_from, _to, _id, _value);\n        require( // solium-disable-line error-reason\n            _checkERC1155AndCallSafeTransfer(\n                metaTransactionContracts[msg.sender] ? _from : msg.sender,\n                _from,\n                _to,\n                _id,\n                _value,\n                _data,\n                false\n            ),\n            \"failCheck\"\n        );\n    }\n\n    // NOTE: call data should be optimized to order _ids so packedBalance can be used efficiently\n    function safeBatchTransferFrom(\n        address _from,\n        address _to,\n        uint256[] calldata _ids,\n        uint256[] calldata _values,\n        bytes calldata _data\n    ) external {\n        _batchTransferFrom(_from, _to, _ids, _values);\n        require( // solium-disable-line error-reason\n            _checkERC1155AndCallSafeBatchTransfer(\n                metaTransactionContracts[msg.sender] ? _from : msg.sender,\n                _from,\n                _to,\n                _ids,\n                _values,\n                _data\n            )\n        );\n    }\n\n    function _batchTransferFrom(\n        address _from,\n        address _to,\n        uint256[] memory _ids,\n        uint256[] memory _values\n    ) internal {\n        require(\n            _ids.length == _values.length,\n            \"Inconsistent array length between args\"\n        );\n        require(_to != address(0), \"Invalid recipient\");\n        require(\n            _from == msg.sender ||\n                _superOperators[msg.sender] ||\n                operatorsForAll[_from][msg.sender] ||\n                metaTransactionContracts[msg.sender],\n            \"not authorized\"\n        );\n\n        uint256 balFrom = packedTokenBalance[_from];\n        uint256 balTo = packedTokenBalance[_to];\n        for (uint256 i = 0; i < _ids.length; i++) {\n            ERC20ORB erc20 = erc20s[_ids[i]];\n            balFrom = ObjectLib64.updateTokenBalance(\n                balFrom,\n                _ids[i],\n                _values[i],\n                ObjectLib64.Operations.SUB\n            );\n            balTo = ObjectLib64.updateTokenBalance(\n                balTo,\n                _ids[i],\n                _values[i],\n                ObjectLib64.Operations.ADD\n            );\n            erc20.emitTransferEvent(_from, _to, _values[i]);\n        }\n        packedTokenBalance[_from] = balFrom;\n        packedTokenBalance[_to] = balTo;\n        emit TransferBatch(\n            metaTransactionContracts[msg.sender] ? _from : msg.sender,\n            _from,\n            _to,\n            _ids,\n            _values\n        );\n    }\n\n    function balanceOf(address _owner, uint256 _tokenId)\n        public\n        view\n        returns (uint256)\n    {\n        if (_tokenId > 2) {\n            return 0;\n        }\n        return packedTokenBalance[_owner].getValueInBin(_tokenId);\n    }\n\n    function balanceOfBatch(\n        address[] calldata _owners,\n        uint256[] calldata _tokenIds\n    ) external view returns (uint256[] memory) {\n        require(\n            _owners.length == _tokenIds.length,\n            \"Inconsistent array length between args\"\n        );\n        uint256[] memory balances = new uint256[](_tokenIds.length);\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\n            balances[i] = balanceOf(_owners[i], _tokenIds[i]);\n        }\n        return balances;\n    }\n\n    function setApprovalForAllFor(\n        address _sender,\n        address _operator,\n        bool _approved\n    ) external {\n        require(\n            msg.sender == _sender ||\n                metaTransactionContracts[msg.sender] ||\n                _superOperators[msg.sender],\n            \"require meta approval\"\n        );\n        _setApprovalForAll(_sender, _operator, _approved);\n    }\n    function setApprovalForAll(address _operator, bool _approved) external {\n        _setApprovalForAll(msg.sender, _operator, _approved);\n    }\n    function _setApprovalForAll(\n        address _sender,\n        address _operator,\n        bool _approved\n    ) internal {\n        require(\n            !_superOperators[_operator],\n            \"super operator can't have their approvalForAll changed\"\n        );\n        operatorsForAll[_sender][_operator] = _approved;\n        emit ApprovalForAll(_sender, _operator, _approved);\n    }\n    function isApprovedForAll(address _owner, address _operator)\n        external\n        view\n        returns (bool isOperator)\n    {\n        return operatorsForAll[_owner][_operator] || _superOperators[_operator];\n    }\n\n    function supportsInterface(bytes4 id) external view returns (bool) {\n        //ERC165            // ERC1155\n        return id == 0x01ffc9a7 || id == 0xd9b67a26;\n    }\n\n    bytes4 private constant ERC1155_IS_RECEIVER = 0x4e2312e0;\n    bytes4 private constant ERC1155_RECEIVED = 0xf23a6e61;\n    bytes4 private constant ERC1155_BATCH_RECEIVED = 0xbc197c81;\n    bytes4 constant ERC165ID = 0x01ffc9a7;\n\n    function checkIsERC1155Receiver(address _contract)\n        internal\n        view\n        returns (bool)\n    {\n        bytes4 erc1155ReceiverID = ERC1155_IS_RECEIVER;\n        bytes4 erc165ID = ERC165ID;\n        bool success;\n        uint256 result;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let x := mload(0x40) // Find empty storage location using \"free memory pointer\"\n            mstore(x, erc165ID) // Place signature at beginning of empty storage\n            mstore(add(x, 0x04), erc1155ReceiverID) // Place first argument directly next to signature\n\n            success := staticcall(\n                10000, // 10k gas\n                _contract, // To addr\n                x, // Inputs are stored at location x\n                0x24, // Inputs are 36 bytes long\n                x, // Store output over input (saves space)\n                0x20\n            ) // Outputs are 32 bytes long\n\n            result := mload(x) // Load the result\n        }\n        // (10000 / 63) \"not enough for supportsInterface(...)\" // consume all gas, so caller can potentially know that there was not enough gas\n        assert(gasleft() > 158);\n        return success && result == 1;\n    }\n\n    function _checkERC1155AndCallSafeTransfer(\n        address _operator,\n        address _from,\n        address _to,\n        uint256 _id,\n        uint256 _value,\n        bytes memory _data,\n        bool _unsafe\n    ) internal returns (bool) {\n        if (!_to.isContract()) {\n            return true;\n        }\n        if (_unsafe && !checkIsERC1155Receiver(_to)) {\n            return true;\n        }\n        return\n            ERC1155TokenReceiver(_to).onERC1155Received(\n                    _operator,\n                    _from,\n                    _id,\n                    _value,\n                    _data\n                ) ==\n                ERC1155_RECEIVED;\n    }\n\n    function _checkERC1155AndCallSafeBatchTransfer(\n        address _operator,\n        address _from,\n        address _to,\n        uint256[] memory _ids,\n        uint256[] memory _values,\n        bytes memory _data\n    ) internal returns (bool) {\n        if (!_to.isContract()) {\n            return true;\n        }\n        bytes4 retval = ERC1155TokenReceiver(_to).onERC1155BatchReceived(\n            _operator,\n            _from,\n            _ids,\n            _values,\n            _data\n        );\n        return (retval == ERC1155_BATCH_RECEIVED);\n    }\n\n}\n","keccak256":"0xf6ec0f84eae161947a0b9bc9eec29c9cab6a63f8e3954b82187138ec2cc9b01e"}}}