{"language":"Solidity","settings":{"evmVersion":"petersburg","libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":2000},"remappings":[]},"sources":{"contracts_common/src/BaseWithStorage/Admin.sol":{"content":"pragma solidity ^0.5.2;\n\ncontract Admin {\n\n    address internal _admin;\n\n    event AdminChanged(address oldAdmin, address newAdmin);\n\n    /// @notice gives the current administrator of this contract.\n    /// @return the current administrator of this contract.\n    function getAdmin() external view returns (address) {\n        return _admin;\n    }\n\n    /// @notice change the administrator to be `newAdmin`.\n    /// @param newAdmin address of the new administrator.\n    function changeAdmin(address newAdmin) external {\n        require(msg.sender == _admin, \"only admin can change admin\");\n        emit AdminChanged(_admin, newAdmin);\n        _admin = newAdmin;\n    }\n\n    modifier onlyAdmin() {\n        require (msg.sender == _admin, \"only admin allowed\");\n        _;\n    }\n\n}\n","keccak256":"0xf3763fa108235379b48cf8fe9a708692fcb077250d9974351fd636ff0baf84bf"},"contracts_common/src/BaseWithStorage/MetaTransactionReceiver.sol":{"content":"pragma solidity ^0.5.2;\n\nimport \"./Admin.sol\";\n\ncontract MetaTransactionReceiver is Admin{\n\n    mapping(address => bool) internal _metaTransactionContracts;\n    event MetaTransactionProcessor(address metaTransactionProcessor, bool enabled);\n\n    /// @notice Enable or disable the ability of `metaTransactionProcessor` to perform meta-tx (metaTransactionProcessor rights).\n    /// @param metaTransactionProcessor address that will be given/removed metaTransactionProcessor rights.\n    /// @param enabled set whether the metaTransactionProcessor is enabled or disabled.\n    function setMetaTransactionProcessor(address metaTransactionProcessor, bool enabled) public {\n        require(\n            msg.sender == _admin,\n            \"only admin can setup metaTransactionProcessors\"\n        );\n        _setMetaTransactionProcessor(metaTransactionProcessor, enabled);\n    }\n\n    function _setMetaTransactionProcessor(address metaTransactionProcessor, bool enabled) internal {\n        _metaTransactionContracts[metaTransactionProcessor] = enabled;\n        emit MetaTransactionProcessor(metaTransactionProcessor, enabled);\n    }\n\n    /// @notice check whether address `who` is given meta-transaction execution rights.\n    /// @param who The address to query.\n    /// @return whether the address has meta-transaction execution rights.\n    function isMetaTransactionProcessor(address who) external view returns(bool) {\n        return _metaTransactionContracts[who];\n    }\n}","keccak256":"0xbd938dbadc0ed2142b6dc20b0613dc3236a9a6ec370639476b672c2536e9a186"},"contracts_common/src/BaseWithStorage/SuperOperators.sol":{"content":"pragma solidity ^0.5.2;\n\nimport \"./Admin.sol\";\n\ncontract SuperOperators is Admin {\n\n    mapping(address => bool) internal _superOperators;\n\n    event SuperOperator(address superOperator, bool enabled);\n\n    /// @notice Enable or disable the ability of `superOperator` to transfer tokens of all (superOperator rights).\n    /// @param superOperator address that will be given/removed superOperator right.\n    /// @param enabled set whether the superOperator is enabled or disabled.\n    function setSuperOperator(address superOperator, bool enabled) external {\n        require(\n            msg.sender == _admin,\n            \"only admin is allowed to add super operators\"\n        );\n        _superOperators[superOperator] = enabled;\n        emit SuperOperator(superOperator, enabled);\n    }\n\n    /// @notice check whether address `who` is given superOperator rights.\n    /// @param who The address to query.\n    /// @return whether the address has superOperator rights.\n    function isSuperOperator(address who) public view returns (bool) {\n        return _superOperators[who];\n    }\n}\n","keccak256":"0x22354cf60ccf77a6de61c13bdaf4e3094d115b960ae563b0527622c846a12abb"},"contracts_common/src/Interfaces/ERC721Events.sol":{"content":"pragma solidity ^0.5.2;\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic interface\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ninterface ERC721Events {\n    event Transfer(\n        address indexed _from,\n        address indexed _to,\n        uint256 indexed _tokenId\n    );\n    event Approval(\n        address indexed _owner,\n        address indexed _approved,\n        uint256 indexed _tokenId\n    );\n    event ApprovalForAll(\n        address indexed _owner,\n        address indexed _operator,\n        bool _approved\n    );\n}\n","keccak256":"0xdf0051d52413d5e853a9801d5745337e4040949b31568cc17ca50f8853e10567"},"contracts_common/src/Interfaces/ERC721TokenReceiver.sol":{"content":"/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\n// solhint-disable-next-line compiler-fixed\npragma solidity ^0.5.2;\n\ninterface ERC721TokenReceiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n","keccak256":"0x94e7441c07cb2f97b9b5be8ca5a5f76623615963852aa5e20208b8cbcb33c1ce"},"contracts_common/src/Libraries/AddressUtils.sol":{"content":"pragma solidity ^0.5.2;\n\nlibrary AddressUtils {\n\n    function toPayable(address _address) internal pure returns (address payable _payable) {\n        return address(uint160(_address));\n    }\n\n    function isContract(address addr) internal view returns (bool) {\n        // for accounts without code, i.e. `keccak256('')`:\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        bytes32 codehash;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            codehash := extcodehash(addr)\n        }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n}\n","keccak256":"0x2ad037f43ea9a899526bd911737727d027ce8a2bc1cf615bdf5a1706d400afd6"},"src/Land.sol":{"content":"/* solhint-disable no-empty-blocks */\n\npragma solidity 0.5.9;\n\nimport \"./Land/erc721/LandBaseToken.sol\";\n\ncontract Land is LandBaseToken {\n    constructor(\n        address metaTransactionContract,\n        address admin\n    ) public LandBaseToken(\n        metaTransactionContract,\n        admin\n    ) {\n    }\n\n    /**\n     * @notice Return the name of the token contract\n     * @return The name of the token contract\n     */\n    function name() external pure returns (string memory) {\n        return \"Sandbox's LANDs\";\n    }\n\n    /**\n     * @notice Return the symbol of the token contract\n     * @return The symbol of the token contract\n     */\n    function symbol() external pure returns (string memory) {\n        return \"LAND\";\n    }\n\n    // solium-disable-next-line security/no-assign-params\n    function uint2str(uint _i) internal pure returns (string memory) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint j = _i;\n        uint len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint k = len - 1;\n        while (_i != 0) {\n            bstr[k--] = byte(uint8(48 + _i % 10));\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n\n    /**\n     * @notice Return the URI of a specific token\n     * @param id The id of the token\n     * @return The URI of the token\n     */\n    function tokenURI(uint256 id) public view returns (string memory) {\n        require(id & LAYER == 0, \"Invalid token id\");\n        require(_ownerOf(id) != address(0), \"Id does not exist\");\n        return\n            string(\n                abi.encodePacked(\n                    \"https://api.sandbox.game/land/\",\n                    uint2str(id),\n                    \"/metadata.json\"\n                )\n            );\n    }\n\n    /**\n     * @notice Check if the contract supports an interface\n     * 0x01ffc9a7 is ERC-165\n     * 0x80ac58cd is ERC-721\n     * 0x5b5e139f is ERC-721 metadata\n     * @param id The id of the interface\n     * @return True if the interface is supported\n     */\n    function supportsInterface(bytes4 id) external pure returns (bool) {\n        return id == 0x01ffc9a7 || id == 0x80ac58cd || id == 0x5b5e139f;\n    }\n\n\n    // TODO ?\n    // function burn(uint256 id) external {\n    //     revert(\"burning is disabled\");\n    // }\n\n    // function burnFrom(address from, uint256 id) external {\n    //     revert(\"burning is disabled\");\n    // }\n}\n","keccak256":"0xf5f28ac68f2b61533db11ad2f1b47c0880a99654140672c7da03eadcaedc40b6"},"src/Land/erc721/LandBaseToken.sol":{"content":"/* solhint-disable func-order, code-complexity */\npragma solidity 0.5.9;\n\nimport \"../../../contracts_common/src/Libraries/AddressUtils.sol\";\nimport \"../../../contracts_common/src/Interfaces/ERC721TokenReceiver.sol\";\nimport \"../../../contracts_common/src/Interfaces/ERC721Events.sol\";\nimport \"../../../contracts_common/src/BaseWithStorage/SuperOperators.sol\";\nimport \"../../../contracts_common/src/BaseWithStorage/MetaTransactionReceiver.sol\";\n\n\n/**\n * @title LandBaseToken\n * @notice This contract is the base of our lands\n */\ncontract LandBaseToken is ERC721Events, SuperOperators, MetaTransactionReceiver {\n    using AddressUtils for address;\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 internal constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // Our grid is 408 x 408 lands\n    uint256 internal constant GRID_SIZE = 408;\n\n    uint256 internal constant LAYER =          0xFF00000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_1x1 =      0x0000000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_3x3 =      0x0100000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_6x6 =      0x0200000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_12x12 =    0x0300000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_24x24 =    0x0400000000000000000000000000000000000000000000000000000000000000;\n\n    mapping (address => uint256) public _numNFTPerAddress;\n    mapping (uint256 => uint256) public _owners;\n    mapping (address => mapping(address => bool)) public _operatorsForAll;\n    mapping (uint256 => address) public _operators;\n\n    mapping(address => bool) internal _minters;\n    event Minter(address superOperator, bool enabled);\n\n    /// @notice Enable or disable the ability of `minter` to mint tokens\n    /// @param minter address that will be given/removed minter right.\n    /// @param enabled set whether the minter is enabled or disabled.\n    function setMinter(address minter, bool enabled) external {\n        require(\n            msg.sender == _admin,\n            \"only admin is allowed to add minters\"\n        );\n        _minters[minter] = enabled;\n        emit Minter(minter, enabled);\n    }\n\n    /// @notice check whether address `who` is given minter rights.\n    /// @param who The address to query.\n    /// @return whether the address has minter rights.\n    function isMinter(address who) public view returns (bool) {\n        return _minters[who];\n    }\n\n    constructor(\n        address metaTransactionContract,\n        address admin\n    ) public {\n        _admin = admin;\n        _setMetaTransactionProcessor(metaTransactionContract, true);\n    }\n\n    /**\n     * @notice Transfer a token between 2 addresses\n     * @param from The send of the token\n     * @param to The recipient of the token\n     * @param id The id of the token\n     */\n    function _transferFrom(address from, address to, uint256 id) internal {\n        require(id & LAYER == 0, \"Invalid token id\");\n        address owner = _ownerOf(id);\n        require(owner != address(0), \"token does not exist\");\n        require(owner == from, \"Specified owner is not the real owner\");\n        require(to != address(0), \"can't send to zero address\");\n        if (msg.sender != from && !_metaTransactionContracts[msg.sender]) {\n            require(\n                _superOperators[msg.sender] ||\n                _operatorsForAll[from][msg.sender] ||\n                _operators[id] == msg.sender,\n                \"Operator not approved to transfer\"\n            );\n        }\n        _numNFTPerAddress[from]--;\n        _numNFTPerAddress[to]++;\n        _owners[id] = uint256(to);\n        _operators[id] = address(0);\n        emit Transfer(from, to, id);\n    }\n\n    /**\n     * @notice Return the balance of an address\n     * @param owner The address to look for\n     * @return The balance of the address\n     */\n    function balanceOf(address owner) external view returns (\n        uint256 _balance\n    ) {\n        require(owner != address(0), \"owner is zero address\");\n        return _numNFTPerAddress[owner];\n    }\n\n    /**\n     * @notice Mint a new block\n     * @param to The recipient of the new block\n     * @param size The size of the new block\n     * @param x The x coordinate of the new block\n     * @param y The y coordinate of the new block\n     */\n    function mintBlock(address to, uint16 size, uint16 x, uint16 y) external {\n        require(\n            isMinter(msg.sender),\n            \"Only a minter can mint\"\n        );\n        require(x % size == 0 && y % size == 0, \"Invalid coordinates\");\n        require(x < GRID_SIZE - size && y < GRID_SIZE - size, \"Out of bounds\");\n\n        uint256 blockId;\n        uint256 id = x + y * GRID_SIZE;\n\n        if (size == 1) {\n            blockId = id;\n        } else if (size == 3) {\n            blockId = LAYER_3x3 + id;\n        } else if (size == 6) {\n            blockId = LAYER_6x6 + id;\n        } else if (size == 12) {\n            blockId = LAYER_12x12 + id;\n        } else if (size == 24) {\n            blockId = LAYER_24x24 + id;\n        } else {\n            require(false, \"Invalid size\");\n        }\n\n        require(_owners[LAYER_24x24 + (x/24) * 24 + ((y/24) * 24) * GRID_SIZE] == 0, \"Already minted as 24x24\");\n\n        uint256 toX = x+size;\n        uint256 toY = y+size;\n        if (size <= 12) {\n            require(\n                _owners[LAYER_12x12 + (x/12) * 12 + ((y/12) * 12) * GRID_SIZE] == 0,\n                \"Already minted as 12x12\"\n            );\n        } else {\n            for (uint16 x12i = x; x12i < toX; x12i += 12) {\n                for (uint16 y12i = y; y12i < toY; y12i += 12) {\n                    uint256 id12x12 = LAYER_12x12 + x12i + y12i * GRID_SIZE;\n                    require(_owners[id12x12] == 0, \"Already minted as 12x12\");\n                }\n            }\n        }\n\n        if (size <= 6) {\n            require(_owners[LAYER_6x6 + (x/6) * 6 + ((y/6) * 6) * GRID_SIZE] == 0, \"Already minted as 6x6\");\n        } else {\n            for (uint16 x6i = x; x6i < toX; x6i += 6) {\n                for (uint16 y6i = y; y6i < toY; y6i += 6) {\n                    uint256 id6x6 = LAYER_6x6 + x6i + y6i * GRID_SIZE;\n                    require(_owners[id6x6] == 0, \"Already minted as 6x6\");\n                }\n            }\n        }\n\n        if (size <= 3) {\n            require(_owners[LAYER_3x3 + (x/3) * 3 + ((y/3) * 3) * GRID_SIZE] == 0, \"Already minted as 3x3\");\n        } else {\n            for (uint16 x3i = x; x3i < toX; x3i += 3) {\n                for (uint16 y3i = y; y3i < toY; y3i += 3) {\n                    uint256 id3x3 = LAYER_3x3 + x3i + y3i * GRID_SIZE;\n                    require(_owners[id3x3] == 0, \"Already minted as 3x3\");\n                }\n            }\n        }\n\n        for (uint16 xi = x; xi < x+size; xi++) {\n            for (uint16 yi = y; yi < y+size; yi++) {\n                uint256 id1x1 = xi + yi * GRID_SIZE;\n                require(_owners[id1x1] == 0, \"Already minted\");\n                emit Transfer(address(0), to, id1x1);\n            }\n        }\n\n        _owners[blockId] = uint256(to);\n        _numNFTPerAddress[to] += size * size;\n    }\n\n    /**\n     * @notice Return the owner of a token\n     * @param id The id of the token\n     * @return The address of the owner\n     */\n    function _ownerOf(uint256 id) internal view returns (address) {\n        uint256 x = id % GRID_SIZE;\n        uint256 y = id / GRID_SIZE;\n        uint256 owner1x1 = _owners[id];\n\n        if (owner1x1 != 0) {\n            return address(owner1x1); // cast to zero\n        } else {\n            address owner3x3 = address(_owners[LAYER_3x3 + (x/3) * 3 + ((y/3) * 3) * GRID_SIZE]);\n            if (owner3x3 != address(0)) {\n                return owner3x3;\n            } else {\n                address owner6x6 = address(_owners[LAYER_6x6 + (x/6) * 6 + ((y/6) * 6) * GRID_SIZE]);\n                if (owner6x6 != address(0)) {\n                    return owner6x6;\n                } else {\n                    address owner12x12 = address(_owners[LAYER_12x12 + (x/12) * 12 + ((y/12) * 12) * GRID_SIZE]);\n                    if (owner12x12 != address(0)) {\n                        return owner12x12;\n                    } else {\n                        return address(_owners[LAYER_24x24 + (x/24) * 24 + ((y/24) * 24) * GRID_SIZE]);\n                    }\n                }\n            }\n        }\n        return address(0); // explicit return\n    }\n\n    /**\n     * @notice Return the owner of a token\n     * @param id The id of the token\n     * @return The address of the owner\n     */\n    function ownerOf(uint256 id) external view returns (address owner) {\n        require(id & LAYER == 0, \"Invalid token id\");\n        owner = _ownerOf(id);\n        require(owner != address(0), \"token does not exist\");\n    }\n\n    /**\n     * @notice Approve an operator to spend tokens on the sender behalf\n     * @param sender The address giving the approval\n     * @param operator The address receiving the approval\n     * @param id The id of the token\n     */\n    function approveFor(\n        address sender,\n        address operator,\n        uint256 id\n    ) external {\n        require(id & LAYER == 0, \"invalid token id\");\n        address owner = _ownerOf(id);\n        require(sender != address(0), \"sender is zero address\");\n        require(\n            msg.sender == sender ||\n            _metaTransactionContracts[msg.sender] ||\n            _superOperators[msg.sender] ||\n            _operatorsForAll[sender][msg.sender],\n            \"not authorized to approve\"\n        );\n        require(owner == sender, \"owner != sender\");\n\n        _operators[id] = operator;\n        emit Approval(sender, operator, id);\n    }\n\n    /**\n     * @notice Approve an operator to spend tokens on the sender behalf\n     * @param operator The address receiving the approval\n     * @param id The id of the token\n     */\n    function approve(address operator, uint256 id) external {\n        require(id & LAYER == 0, \"Invalid token id\");\n        address owner = _ownerOf(id);\n        require(owner != address(0), \"token does not exist\");\n        require(\n            owner == msg.sender ||\n            _superOperators[msg.sender] ||\n            _operatorsForAll[owner][msg.sender],\n            \"not authorized to approve\"\n        );\n        _operators[id] = operator;\n        emit Approval(msg.sender, operator, id);\n    }\n\n    /**\n     * @notice Get the approved operator for a specific token\n     * @param id The id of the token\n     * @return The address of the operator\n     */\n    function getApproved(uint256 id) external view returns (address) {\n        require(id & LAYER == 0, \"Invalid token id\");\n        require(_ownerOf(id) != address(0), \"token does not exist\");\n        return _operators[id];\n    }\n\n    /**\n     * @notice Transfer a token between 2 addresses\n     * @param from The sender of the token\n     * @param to The recipient of the token\n     * @param id The id of the token\n    */\n    function transferFrom(address from, address to, uint256 id) external {\n        _transferFrom(from, to, id);\n    }\n\n    /**\n     * @notice Transfer a token between 2 addresses letting the receiver knows of the transfer\n     * @param from The sender of the token\n     * @param to The recipient of the token\n     * @param id The id of the token\n     * @param data Additional data\n     */\n    function safeTransferFrom(address from, address to, uint256 id, bytes memory data) public {\n        _transferFrom(from, to, id);\n        require(\n            _checkOnERC721Received(from, to, id, data),\n            \"ERC721: transfer rejected\"\n        );\n    }\n\n    /**\n     * @notice Transfer a token between 2 addresses letting the receiver knows of the transfer\n     * @param from The send of the token\n     * @param to The recipient of the token\n     * @param id The id of the token\n     */\n    function safeTransferFrom(address from, address to, uint256 id) external {\n        safeTransferFrom(from, to, id, \"\");\n    }\n\n    /**\n     * @notice Transfer many tokens between 2 addresses\n     * @param from The sender of the token\n     * @param to The recipient of the token\n     * @param ids The ids of the tokens\n    */\n    function batchTransferFrom(address from, address to, uint256[] calldata ids) external {\n        bool authorized = msg.sender == from ||\n            _metaTransactionContracts[msg.sender] ||\n            _superOperators[msg.sender] ||\n            _operatorsForAll[from][msg.sender];\n\n        uint256 numTokens = ids.length;\n        require(from != address(0), \"from is zero address\");\n        require(to != address(0), \"can't send to zero address\");\n\n        for(uint256 i = 0; i < numTokens; i ++) {\n            uint256 id = ids[i];\n            require(id & LAYER == 0, \"Invalid token id\");\n            address owner = _ownerOf(id);\n            require(owner == from, \"Specified owner is not the real owner\");\n            require(authorized || _operators[id] == msg.sender, \"not authorized\");\n            _owners[id] = uint256(to);\n            _operators[id] = address(0);\n            emit Transfer(from, to, id);\n        }\n\n        _numNFTPerAddress[from] -= numTokens;\n        _numNFTPerAddress[to] += numTokens;\n    }\n\n    /**\n     * @notice Check if the contract supports an interface\n     * 0x01ffc9a7 is ERC-165\n     * 0x80ac58cd is ERC-721\n     * @param id The id of the interface\n     * @return True if the interface is supported\n     */\n    function supportsInterface(bytes4 id) external pure returns (bool) {\n        return id == 0x01ffc9a7 || id == 0x80ac58cd;\n    }\n\n    /**\n     * @notice Set the approval for an operator to manage all the tokens of the sender\n     * @param sender The address giving the approval\n     * @param operator The address receiving the approval\n     * @param approved The determination of the approval\n     */\n    function setApprovalForAllFor(\n        address sender,\n        address operator,\n        bool approved\n    ) external {\n        require(sender != address(0), \"Invalid sender address\");\n        require(\n            msg.sender == sender ||\n            _metaTransactionContracts[msg.sender] ||\n            _superOperators[msg.sender],\n            \"not authorized to approve for all\"\n        );\n\n        _setApprovalForAll(sender, operator, approved);\n    }\n\n    /**\n     * @notice Set the approval for an operator to manage all the tokens of the sender\n     * @param operator The address receiving the approval\n     * @param approved The determination of the approval\n     */\n    function setApprovalForAll(address operator, bool approved) external {\n        _setApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /**\n     * @notice Set the approval for an operator to manage all the tokens of the sender\n     * @param sender The address giving the approval\n     * @param operator The address receiving the approval\n     * @param approved The determination of the approval\n     */\n    function _setApprovalForAll(\n        address sender,\n        address operator,\n        bool approved\n    ) internal {\n        require(\n            !_superOperators[operator],\n            \"super operator can't have their approvalForAll changed\"\n        );\n        _operatorsForAll[sender][operator] = approved;\n\n        emit ApprovalForAll(sender, operator, approved);\n    }\n\n    /**\n     * @notice Check if the sender approved the operator\n     * @param owner The address of the owner\n     * @param operator The address of the operator\n     * @return The status of the approval\n     */\n    function isApprovedForAll(address owner, address operator)\n        external\n        view\n        returns (bool isOperator)\n    {\n        return _operatorsForAll[owner][operator] || _superOperators[operator];\n    }\n\n    function _burn(address from, uint256 id) public {\n        require(from == _ownerOf(id), \"not owner\");\n        _owners[id] = 2**160;\n        _numNFTPerAddress[from]--;\n        emit Transfer(from, address(0), id);\n    }\n\n    /// @notice Burns token `id`.\n    /// @param id token which will be burnt.\n    function burn(uint256 id) external {\n        _burn(msg.sender, id);\n    }\n\n    /// @notice Burn token`id` from `from`.\n    /// @param from address whose token is to be burnt.\n    /// @param id token which will be burnt.\n    function burnFrom(address from, uint256 id) external {\n        require(from != address(0), \"from is zero address\");\n        require(\n            msg.sender == from ||\n            _metaTransactionContracts[msg.sender] ||\n            _superOperators[msg.sender] ||\n            _operatorsForAll[from][msg.sender],\n            \"not authorized to burn\"\n        );\n        _burn(from, id);\n    }\n\n    /**\n     * @notice Internal function to invoke `onERC721Received` on a target address.\n     * The call is not executed if the target address is not a contract.\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        internal returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n\n        bytes4 retval = ERC721TokenReceiver(to).onERC721Received(msg.sender, from, tokenId, _data);\n        return (retval == _ERC721_RECEIVED);\n    }\n}\n","keccak256":"0x7520a708c99edc7c597785422e6c6d42e595c234ffb04d5a393a1694bde9f6bd"}}}