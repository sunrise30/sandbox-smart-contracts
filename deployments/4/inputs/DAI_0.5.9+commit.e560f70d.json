{"language":"Solidity","settings":{"evmVersion":"petersburg","libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":2000},"remappings":[]},"sources":{"contracts_common/src/BaseWithStorage/Admin.sol":{"content":"pragma solidity ^0.5.2;\n\ncontract Admin {\n\n    address internal _admin;\n\n    event AdminChanged(address oldAdmin, address newAdmin);\n\n    /// @notice gives the current administrator of this contract.\n    /// @return the current administrator of this contract.\n    function getAdmin() external view returns (address) {\n        return _admin;\n    }\n\n    /// @notice change the administrator to be `newAdmin`.\n    /// @param newAdmin address of the new administrator.\n    function changeAdmin(address newAdmin) external {\n        require(msg.sender == _admin, \"only admin can change admin\");\n        emit AdminChanged(_admin, newAdmin);\n        _admin = newAdmin;\n    }\n}\n","keccak256":"0x74418caab05cca3fe5b9309ab069a9bfe327ff96f593a347e1f1cc0c02f25693"},"contracts_common/src/BaseWithStorage/SuperOperators.sol":{"content":"pragma solidity ^0.5.2;\n\nimport \"./Admin.sol\";\n\ncontract SuperOperators is Admin {\n\n    mapping(address => bool) internal _superOperators;\n\n    event SuperOperator(address superOperator, bool enabled);\n\n    /// @notice Enable or disable the ability of `superOperator` to transfer tokens of all (superOperator rights).\n    /// @param superOperator address that will be given/removed superOperator right.\n    /// @param enabled set whether the superOperator is enabled or disabled.\n    function setSuperOperator(address superOperator, bool enabled) external {\n        require(\n            msg.sender == _admin,\n            \"only admin is allowed to add super operators\"\n        );\n        _superOperators[superOperator] = enabled;\n        emit SuperOperator(superOperator, enabled);\n    }\n\n    /// @notice check whether address `who` is given superOperator rights.\n    /// @param who The address to query.\n    /// @return whether the address has superOperator rights.\n    function isSuperOperator(address who) public view returns (bool) {\n        return _superOperators[who];\n    }\n}\n","keccak256":"0x22354cf60ccf77a6de61c13bdaf4e3094d115b960ae563b0527622c846a12abb"},"contracts_common/src/Interfaces/ERC20Events.sol":{"content":"pragma solidity ^0.5.2;\n\n/* interface */\ncontract ERC20Events {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n","keccak256":"0xee09c10a3f9adc913227efdcd94ce44e05b59b04717f8f868153d356bd03f5d2"},"src/Sand/erc20/ERC20BaseToken.sol":{"content":"pragma solidity 0.5.9;\n\nimport \"../../../contracts_common/src/Interfaces/ERC20Events.sol\";\nimport \"../../../contracts_common/src/BaseWithStorage/SuperOperators.sol\";\n\ncontract ERC20BaseToken is SuperOperators, ERC20Events {\n\n    uint256 internal _totalSupply;\n    mapping(address => uint256) internal _balances;\n    mapping(address => mapping(address => uint256)) internal _allowances;\n\n    /// @notice Gets the total number of tokens in existence.\n    /// @return the total number of tokens in existence.\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /// @notice Gets the balance of `owner`.\n    /// @param owner The address to query the balance of.\n    /// @return The amount owned by `owner`.\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\n\n    /// @notice gets allowance of `spender` for `owner`'s tokens.\n    /// @param owner address whose token is allowed.\n    /// @param spender address allowed to transfer.\n    /// @return the amount of token `spender` is allowed to transfer on behalf of `owner`.\n    function allowance(address owner, address spender)\n        public\n        view\n        returns (uint256 remaining)\n    {\n        return _allowances[owner][spender];\n    }\n\n    /// @notice returns the number of decimals for that token.\n    /// @return the number of decimals.\n    function decimals() public view returns (uint8) {\n        return uint8(18);\n    }\n\n    /// @notice Transfer `amount` tokens to `to`.\n    /// @param to the recipient address of the tokens transfered.\n    /// @param amount the number of tokens transfered.\n    /// @return true if success.\n    function transfer(address to, uint256 amount)\n        public\n        returns (bool success)\n    {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /// @notice Transfer `amount` tokens from `from` to `to`.\n    /// @param from whose token it is transferring from.\n    /// @param to the recipient address of the tokens transfered.\n    /// @param amount the number of tokens transfered.\n    /// @return true if success.\n    function transferFrom(address from, address to, uint256 amount)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != from && !_superOperators[msg.sender]) {\n            uint256 currentAllowance = _allowances[from][msg.sender];\n            if (currentAllowance != (2**256) - 1) {\n                // save gas when allowance is maximal by not reducing it (see https://github.com/ethereum/EIPs/issues/717)\n                require(currentAllowance >= amount, \"Not enough funds allowed\");\n                _allowances[from][msg.sender] = currentAllowance - amount;\n            }\n        }\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /// @notice burn `amount` tokens.\n    /// @param amount the number of tokens to burn.\n    /// @return true if success.\n    function burn(uint256 amount) external returns (bool) {\n        _burn(msg.sender, amount);\n        return true;\n    }\n\n    /// @notice burn `amount` tokens from `owner`.\n    /// @param owner address whose token is to burn.\n    /// @param amount the number of token to burn.\n    /// @return true if success.\n    function burnFor(address owner, uint256 amount) external returns (bool) {\n        _burn(owner, amount);\n        return true;\n    }\n\n    /// @notice approve `spender` to transfer `amount` tokens.\n    /// @param spender address to be given rights to transfer.\n    /// @param amount the number of tokens allowed.\n    /// @return true if success.\n    function approve(address spender, uint256 amount)\n        public\n        returns (bool success)\n    {\n        _approveFor(msg.sender, spender, amount);\n        return true;\n    }\n\n    /// @notice approve `spender` to transfer `amount` tokens from `owner`.\n    /// @param owner address whose token is allowed.\n    /// @param spender  address to be given rights to transfer.\n    /// @param amount the number of tokens allowed.\n    /// @return true if success.\n    function approveFor(address owner, address spender, uint256 amount)\n        public\n        returns (bool success)\n    {\n        require(\n            msg.sender == owner || _superOperators[msg.sender],\n            \"msg.sender != from || superOperator\"\n        );\n        _approveFor(owner, spender, amount);\n        return true;\n    }\n\n    function _approveFor(address owner, address spender, uint256 amount)\n        internal\n    {\n        require(\n            owner != address(0) && spender != address(0),\n            \"Cannot approve with 0x0\"\n        );\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _approveForWithoutEvent(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal {\n        require(\n            owner != address(0) && spender != address(0),\n            \"Cannot approve with 0x0\"\n        );\n        _allowances[owner][spender] = amount;\n    }\n\n    function _transfer(address from, address to, uint256 amount) internal {\n        require(amount > 0, \"can't transfer 0 token\");\n        _transferBalance(from, to, amount);\n        _emitTransferEvent(from, to, amount);\n    }\n\n    function _transferBalance(address from, address to, uint256 amount)\n        internal\n    {\n        require(to != address(0), \"Cannot send to 0x0\");\n        uint256 currentBalance = _balances[from];\n        require(currentBalance >= amount, \"not enough fund\");\n        _balances[from] = currentBalance - amount;\n        _balances[to] += amount;\n    }\n\n    function _emitTransferEvent(address from, address to, uint256 amount)\n        internal\n    {\n        emit Transfer(from, to, amount);\n    }\n\n    function _mint(address to, uint256 amount) internal {\n        require(to != address(0), \"Cannot mint to 0x0\");\n        require(amount > 0, \"cannot mint 0 tokens\");\n        uint256 currentTotalSupply = _totalSupply;\n        uint256 newTotalSupply = currentTotalSupply + amount;\n        require(newTotalSupply > currentTotalSupply, \"overflow\");\n        _totalSupply = newTotalSupply;\n        _balances[to] += amount;\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal {\n        require(amount > 0, \"cannot burn 0 tokens\");\n        if (msg.sender != from && !_superOperators[msg.sender]) {\n            uint256 currentAllowance = _allowances[from][msg.sender];\n            require(\n                currentAllowance >= amount,\n                \"Not enough funds allowed\"\n            );\n            if (currentAllowance != (2**256) - 1) {\n                // save gas when allowance is maximal by not reducing it (see https://github.com/ethereum/EIPs/issues/717)\n                _allowances[from][msg.sender] = currentAllowance - amount;\n            }\n        }\n\n        uint256 currentBalance = _balances[from];\n        require(currentBalance >= amount, \"Not enough funds\");\n        _balances[from] = currentBalance - amount;\n        _totalSupply -= amount;\n        emit Transfer(from, address(0), amount);\n    }\n}\n","keccak256":"0x91d81f9731f0b9525b1ce1815cbcaaa48a3f1a050a80261c299229167203e386"},"src/Test/FakeDai.sol":{"content":"pragma solidity 0.5.9;\n\nimport '../Sand/erc20/ERC20BaseToken.sol';\n\n\ncontract FakeDai is ERC20BaseToken {\n  constructor() public {\n    _mint(msg.sender, 3000000000 * 10 ** 18);\n  }\n}\n","keccak256":"0xd221817d8e5e9943ab5dc4bd13ec9b9630ec20d0e8ca666e731947140a0647e8"}}}